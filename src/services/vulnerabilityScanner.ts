
interface VulnerabilityReport {
  id: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  type: 'dependency' | 'code' | 'configuration' | 'security_header';
  title: string;
  description: string;
  recommendation: string;
  affected_component: string;
  detected_at: Date;
  status: 'open' | 'acknowledged' | 'fixed' | 'false_positive';
}

interface SecurityAuditResult {
  overall_score: number;
  vulnerabilities: VulnerabilityReport[];
  compliance_status: {
    gdpr: boolean;
    hipaa: boolean;
    security_headers: boolean;
    data_encryption: boolean;
  };
  recommendations: string[];
}

export class VulnerabilityScanner {
  private static instance: VulnerabilityScanner;
  private vulnerabilities: VulnerabilityReport[] = [];

  private constructor() {}

  static getInstance(): VulnerabilityScanner {
    if (!VulnerabilityScanner.instance) {
      VulnerabilityScanner.instance = new VulnerabilityScanner();
    }
    return VulnerabilityScanner.instance;
  }

  async performSecurityAudit(): Promise<SecurityAuditResult> {
    console.log('VulnerabilityScanner: Starting comprehensive security audit...');
    
    const vulnerabilities: VulnerabilityReport[] = [];
    
    // Check for security headers
    const headerVulns = await this.checkSecurityHeaders();
    vulnerabilities.push(...headerVulns);
    
    // Check for XSS vulnerabilities
    const xssVulns = await this.checkXSSVulnerabilities();
    vulnerabilities.push(...xssVulns);
    
    // Check for CSRF vulnerabilities
    const csrfVulns = await this.checkCSRFProtection();
    vulnerabilities.push(...csrfVulns);
    
    // Check authentication security
    const authVulns = await this.checkAuthenticationSecurity();
    vulnerabilities.push(...authVulns);
    
    // Check data encryption status
    const encryptionVulns = await this.checkDataEncryption();
    vulnerabilities.push(...encryptionVulns);
    
    // Store vulnerabilities
    this.vulnerabilities = vulnerabilities;
    
    // Calculate overall security score
    const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    const mediumCount = vulnerabilities.filter(v => v.severity === 'medium').length;
    const lowCount = vulnerabilities.filter(v => v.severity === 'low').length;
    
    const totalScore = 100;
    const deductions = (criticalCount * 25) + (highCount * 15) + (mediumCount * 8) + (lowCount * 3);
    const overallScore = Math.max(0, totalScore - deductions);
    
    // Check compliance status
    const complianceStatus = {
      gdpr: this.checkGDPRCompliance(vulnerabilities),
      hipaa: this.checkHIPAACompliance(vulnerabilities),
      security_headers: headerVulns.length === 0,
      data_encryption: encryptionVulns.length === 0
    };
    
    // Generate recommendations
    const recommendations = this.generateRecommendations(vulnerabilities);
    
    const result: SecurityAuditResult = {
      overall_score: overallScore,
      vulnerabilities,
      compliance_status: complianceStatus,
      recommendations
    };
    
    console.log('VulnerabilityScanner: Security audit completed', result);
    return result;
  }

  private async checkSecurityHeaders(): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];
    
    try {
      const response = await fetch(window.location.origin, { method: 'HEAD' });
      const headers = response.headers;
      
      const requiredHeaders = [
        'content-security-policy',
        'x-frame-options',
        'x-content-type-options',
        'strict-transport-security',
        'referrer-policy'
      ];
      
      for (const header of requiredHeaders) {
        if (!headers.get(header)) {
          vulnerabilities.push({
            id: crypto.randomUUID(),
            severity: header === 'content-security-policy' ? 'high' : 'medium',
            type: 'security_header',
            title: `Missing ${header.toUpperCase()} header`,
            description: `The ${header} security header is not set, which may leave the application vulnerable to attacks.`,
            recommendation: `Implement the ${header} header with appropriate values.`,
            affected_component: 'HTTP Headers',
            detected_at: new Date(),
            status: 'open'
          });
        }
      }
    } catch (error) {
      console.error('Failed to check security headers:', error);
    }
    
    return vulnerabilities;
  }

  private async checkXSSVulnerabilities(): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];
    
    // Check for potential XSS in user inputs
    const inputs = document.querySelectorAll('input, textarea');
    let unsanitizedInputs = 0;
    
    inputs.forEach(input => {
      // Simple check for inputs without proper validation attributes
      if (!input.hasAttribute('maxlength') && input.getAttribute('type') !== 'email') {
        unsanitizedInputs++;
      }
    });
    
    if (unsanitizedInputs > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        severity: 'medium',
        type: 'code',
        title: 'Potential XSS vulnerability in user inputs',
        description: `${unsanitizedInputs} input fields may be vulnerable to XSS attacks due to insufficient validation.`,
        recommendation: 'Implement proper input validation and sanitization for all user inputs.',
        affected_component: 'User Input Forms',
        detected_at: new Date(),
        status: 'open'
      });
    }
    
    return vulnerabilities;
  }

  private async checkCSRFProtection(): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];
    
    // Check if CSRF tokens are being used
    const forms = document.querySelectorAll('form');
    let formsWithoutCSRF = 0;
    
    forms.forEach(form => {
      const csrfToken = form.querySelector('input[name*="csrf"], input[name*="token"]');
      if (!csrfToken && form.method?.toLowerCase() === 'post') {
        formsWithoutCSRF++;
      }
    });
    
    if (formsWithoutCSRF > 0) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        severity: 'high',
        type: 'code',
        title: 'Missing CSRF protection',
        description: `${formsWithoutCSRF} forms may be vulnerable to CSRF attacks.`,
        recommendation: 'Implement CSRF tokens for all state-changing forms.',
        affected_component: 'Forms',
        detected_at: new Date(),
        status: 'open'
      });
    }
    
    return vulnerabilities;
  }

  private async checkAuthenticationSecurity(): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];
    
    // Check password policy
    const hasPasswordPolicy = localStorage.getItem('password_policy_enforced');
    if (!hasPasswordPolicy) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        severity: 'medium',
        type: 'configuration',
        title: 'Weak password policy',
        description: 'Password policy enforcement is not properly configured.',
        recommendation: 'Implement strong password requirements (minimum 8 characters, complexity rules).',
        affected_component: 'Authentication System',
        detected_at: new Date(),
        status: 'open'
      });
    }
    
    // Check session management
    const sessionTimeout = sessionStorage.getItem('session_timeout');
    if (!sessionTimeout) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        severity: 'medium',
        type: 'configuration',
        title: 'No session timeout configured',
        description: 'User sessions do not have automatic timeout configured.',
        recommendation: 'Implement automatic session timeout for idle users.',
        affected_component: 'Session Management',
        detected_at: new Date(),
        status: 'open'
      });
    }
    
    return vulnerabilities;
  }

  private async checkDataEncryption(): Promise<VulnerabilityReport[]> {
    const vulnerabilities: VulnerabilityReport[] = [];
    
    // Check if sensitive data is encrypted
    const encryptedData = localStorage.getItem('therapyAppEncryptionKey');
    if (!encryptedData) {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        severity: 'critical',
        type: 'configuration',
        title: 'Data encryption not enabled',
        description: 'Sensitive user data is not being encrypted at rest.',
        recommendation: 'Enable data encryption for all sensitive information.',
        affected_component: 'Data Storage',
        detected_at: new Date(),
        status: 'open'
      });
    }
    
    // Check HTTPS usage
    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
      vulnerabilities.push({
        id: crypto.randomUUID(),
        severity: 'critical',
        type: 'configuration',
        title: 'Application not served over HTTPS',
        description: 'The application is not using HTTPS, making data transmission vulnerable.',
        recommendation: 'Enable HTTPS for all application traffic.',
        affected_component: 'Transport Security',
        detected_at: new Date(),
        status: 'open'
      });
    }
    
    return vulnerabilities;
  }

  private checkGDPRCompliance(vulnerabilities: VulnerabilityReport[]): boolean {
    // Check for GDPR compliance indicators
    const hasDataProtection = !vulnerabilities.some(v => 
      v.title.includes('encryption') || v.title.includes('data protection')
    );
    const hasPrivacyPolicy = document.querySelector('[href*="privacy"]') !== null;
    
    return hasDataProtection && hasPrivacyPolicy;
  }

  private checkHIPAACompliance(vulnerabilities: VulnerabilityReport[]): boolean {
    // Check for HIPAA compliance indicators
    const hasEncryption = !vulnerabilities.some(v => v.title.includes('encryption'));
    const hasAccessControls = !vulnerabilities.some(v => v.title.includes('authentication'));
    
    return hasEncryption && hasAccessControls;
  }

  private generateRecommendations(vulnerabilities: VulnerabilityReport[]): string[] {
    const recommendations: string[] = [];
    
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'critical');
    const highVulns = vulnerabilities.filter(v => v.severity === 'high');
    
    if (criticalVulns.length > 0) {
      recommendations.push('🚨 Address critical vulnerabilities immediately - these pose immediate security risks');
    }
    
    if (highVulns.length > 0) {
      recommendations.push('⚠️ High severity vulnerabilities should be addressed within 24-48 hours');
    }
    
    if (vulnerabilities.some(v => v.type === 'security_header')) {
      recommendations.push('🛡️ Implement security headers to protect against common web vulnerabilities');
    }
    
    if (vulnerabilities.some(v => v.title.includes('encryption'))) {
      recommendations.push('🔒 Enable end-to-end encryption for all sensitive data');
    }
    
    if (vulnerabilities.some(v => v.title.includes('CSRF'))) {
      recommendations.push('🔐 Implement CSRF protection for all state-changing operations');
    }
    
    recommendations.push('📊 Schedule regular security audits and penetration testing');
    recommendations.push('🔄 Keep all dependencies updated to latest secure versions');
    
    return recommendations;
  }

  getVulnerabilities(): VulnerabilityReport[] {
    return this.vulnerabilities;
  }

  async markVulnerabilityAsFixed(vulnerabilityId: string): Promise<void> {
    const vulnIndex = this.vulnerabilities.findIndex(v => v.id === vulnerabilityId);
    if (vulnIndex !== -1) {
      this.vulnerabilities[vulnIndex].status = 'fixed';
      console.log(`Vulnerability ${vulnerabilityId} marked as fixed`);
    }
  }
}

export const vulnerabilityScanner = VulnerabilityScanner.getInstance();
